# stm32stand_ui

Данный проект (далее - UI) представляет собой попытку реализации
интерфейса пользователя для управления стендом, аппаратная логика
работы которого реализована в проекте `stm32stand`.

Проект `stm32stand` представляет собой прошивку для `STM32` (далее -
МК), в которой осуществляется поддержка необходимой перифирии, а также
реализован интерфейс взаимодействия с ПК посредством `USB`
(используется `tinyusb`).

## Описание реализации

Взоимодействие UI с прошивкой реализовано через USB, а именно через
CDC драйвер, представляющий для хост-системы аналог COM-порта.

Поток данных состоит из 2-х "каналов": канала телеметрии и канала
управления. Телеметрия со стороны МК отправляется постоянно, тогда как
канал управления используется для передачи команд управления в сторону
МК.

На данный момент реализована поддержка следующей телеметрии:

 - таймстемп (мс)
 - значение текущего газа
 - положение тормозного диска
 - значение нагрузки с тензодатчика (HX711)
 - значение температуры с термопары (MAX6675) x 2 шт
 - TODO: значение температуры с ИК-датчика
 - значение тока, напряжения и мощности (INA236)
 - значение оборотов двигателя (оптический датчик)
 - значения вибрации с гироскопа (MAX6050)

Для описания логики теста используется встроенный в UI интерпретатор
`lua` где реализованы 2 группы команд: команды управления логикой
теста и команды управления устройствм выполняемые на стороне МК.

### Структура программы-теста

Общая структура программы выглядит следующим образом:

~~~
local function onConnect()
   -- коллбек, вызывается автоматически
end

local function onTelemetry(t)
   -- коллбек, вызывается автоматически
end

local function onDisconnect()
   -- коллбек, вызывается автоматически
end

local function test()
   -- логика теста ...
end

return {
   Test         = test,
   OnConnect    = onConnect,
   OnTelemetry  = onTelemetry,
   OnDisconnect = onDisconnect,
}
~~~

Как видно, программа теста состоит из нескольких функций, являющихся параметрами возвращаемого объекта.

Коллбеки `onConnect()` и `onDisconnect()` вызываются автоматически и соответствуют фазам подключения и отключения устройства.

Коллбек `onTelemetry(t)` вызывается автоматически в момент получения телеметрии от устройства. Аргументом является объект телеметрии, который далее будет использован для сохранения в файл. Таким образом, допускается изменение показаний телеметрии на лету, если это требуется. Например, могут применяться какие-то нормирующие множители и т.п.

Объект телеметрии представляет собой структуру с полями, доступ к которым осуществляется по имени (например, `t.MotorRPM`):

~~~
type struct telemetry {
        Ts int32
        Load int32
        Temp1 float64
        Temp2 float64
        Temp3 float64
        Brake int32
        MotorI float64
        MotorU float64
        MotorP float64
        MotorRPM int32
        Throttle int32
        GyroX int32
        GyroY int32
        GyroZ int32
        Tag string
}
~~~

Работа функций `test` и `onTelemetry(t)` ведётся в разных потоках, то есть они друг-друга не блокируют.

### Команды управления логикой

`sleep(n)` -- ожидание, мс

`strParam(arg, val)` -- получить строковый аргумент, передаваемый через параметр командной строки `--args arg=str`. В случае, если нет параметра используется значение `val`.

`intParam(arg, val)` -- получить целочисленный аргумент, передаваемый через параметр командной строки `--args arg=int`. В случае, если нет параметра используется значение `val`.

`stop(msg)` -- экстренная остановка теста

### Команды управления устройством

`id()` -- идентификация устройства

Данная команда запрашивает идентификатор устройства, возвращает строку-описание.

`tare()` -- тарирование счётчиков

Данная команда выставляет в ноль счётчик позиции диска-тормоза, а также приводит к "нулю" показания тензодатчика.

`sample(n)` -- частота отправки телеметрии

Данная команда устанавливает периодичность отправки телеметрии. Штатное значение - 10 мс.

`brake(n, arg)` -- управление дисковым тормозом

Данная команда управляет положением дискового тормоза.

Дисковый тормоз может двигаться вперёд и назад, а также имеет функцию автоматического "возврата" в начальное положение.

Команда `brake(0,  0)` запускает процесс автоматического возврата диска в "нулевое" положение, определяемое моментом исполнения команды `tare()`.

Команда `brake(1, +N)` запускает процесс автоматического движения диска вперёд (по направлению к двигателю), N определяет количество шагов.

Команда `brake(1, -N)` запускает процесс автоматического движения диска назад (по направлению от двигателя), N определяет количество шагов.

Команда `brake(1,  0)` остановит движение диска, если таковое имело место быть.

`chiller(n, arg)` -- управление вентиляторами

Команда `chiller(0, 0)` выключит вентиляторы.

Команда `chiller(0, N)` выключит вентиляторы через N мс.

Команда `chiller(1, N)` включит вентиляторы и выставит % мощности (N = 1-100).

`throttle(n)` -- управление "газом" мотора

Данная команда устанавливает значение "газа" мотора, а именно управляет шириной импульса (ШИМ) регулятора оборотов в соответствии с протоколом ESC.

Диапазон значений: от 1000 мкс до 2000 мкс.

Команда `throttle(0)` запустит автоматическое снижение оборотов двигателя (шаг 50 мкс, задержка 200 мс) до минимального значения 1000 мкс.
